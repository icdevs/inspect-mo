# Inspect-Mo: API Reference & Examples

**üìù Current API Status**: This documentation reflects the **current ErasedValidator API** implemented in the library. Some example files in the `examples/` directory may show older API patterns and are being updated.

## Core API Overview

The Inspect-Mo library provides validation at two different execution points using an **ErasedValidator** pattern for type-safe, efficient validation:

1. **Inspect Pattern**: Validation during system `inspect_message` calls
2. **Guard Pattern**: Validation within method implementations with full context

### ErasedValidator Architecture

The library uses a sophisticated **function generator** approach to solve type erasure challenges:

- **Registration Time**: Full type information available, validation logic "baked" into type-erased functions
- **Execution Time**: Simple function calls with no type complexity
- **Storage**: All methods stored in same BTree regardless of their individual type parameters

## Basic Usage

```motoko
import InspectMo "mo:inspect-mo";
import Debug "mo:core/Debug";
import Error "mo:core/Error";
import Principal "mo:core/Principal";

actor MyCanister {
  type MessageAccessor = {
    #update_profile : (Text, Text); // (bio, displayName)
    #get_profile : (Principal);
  };

  // Initialize inspector with global configuration
  private let config: InspectMo.InitArgs = {
    allowAnonymous = ?false;
    defaultMaxArgSize = ?1024 * 1024; // 1MB default
    authProvider = null;
    rateLimit = null;
    queryDefaults = ?{ allowAnonymous = true; maxArgSize = 10_000; rateLimit = null };
    updateDefaults = ?{ allowAnonymous = false; maxArgSize = 1024 * 1024; rateLimit = null };
    developmentMode = false;
    auditLog = true;
  };

  private let inspectMo = InspectMo.InspectMo(
    null,
    Principal.fromActor(MyCanister),
    Principal.fromActor(MyCanister),
    ?config,
    null,
    func(_state) {}
  );
  
  private let inspector = inspectMo.createInspector<MessageAccessor>();

  // Register inspect validation (ErasedValidator pattern)
  let updateProfileInspectInfo = inspector.createMethodGuardInfo<(Text, Text)>(
    "update_profile",
    false,
    [
      InspectMo.textSize<MessageAccessor, (Text, Text)>(func(args: (Text, Text)): Text { args.0 }, null, ?5000),
      InspectMo.textSize<MessageAccessor, (Text, Text)>(func(args: (Text, Text)): Text { args.1 }, ?1, ?100),
      InspectMo.requireAuth<MessageAccessor, (Text, Text)>()
    ],
    func(msg: MessageAccessor) : (Text, Text) = switch(msg) {
      case (#update_profile(bio, displayName)) (bio, displayName);
      case (_) Debug.trap("Wrong message type");
    }
  );
  inspector.inspect(updateProfileInspectInfo);

  // Register guard validation with business logic
  let updateProfileGuardInfo = inspector.createMethodGuardInfo<(Text, Text)>(
    "update_profile",
    false,
    [
      InspectMo.customCheck<MessageAccessor, (Text, Text)>(
        func(args: InspectMo.CustomCheckArgs<MessageAccessor>): InspectMo.GuardResult {
          switch (args.args) {
            case (#update_profile(_bio, _displayName)) { #ok };
            case (_) #err("Invalid message variant");
          }
        }
      )
    ],
    func(msg: MessageAccessor) : (Text, Text) = switch(msg) {
      case (#update_profile(bio, displayName)) (bio, displayName);
      case (_) Debug.trap("Wrong message type");
    }
  );
  inspector.guard(updateProfileGuardInfo);

  public shared(msg) func update_profile(bio: Text, displayName: Text): async () {
    let args : InspectMo.InspectArgs<MessageAccessor> = {
      methodName = "update_profile";
      caller = msg.caller;
      arg = to_candid(bio, displayName);
      isQuery = false;
      cycles = null;
      deadline = null;
      isInspect = false;
      msg = #update_profile(bio, displayName);
    };

    switch (inspector.guardCheck(args)) {
      case (#ok) { /* implementation */ };
      case (#err(errMsg)) { throw Error.reject(errMsg) };
    }
  };

  system func inspect({ caller : Principal; method_name : Text; arg : Blob; msg : MessageAccessor; }) : Bool {
    let args : InspectMo.InspectArgs<MessageAccessor> = {
      methodName = method_name;
      caller = caller;
      arg = arg;
      isQuery = false;
      cycles = null;
      deadline = null;
      isInspect = true;
      msg = msg;
    };
    switch (inspector.inspectCheck(args)) { case (#ok) true; case (#err(_)) false };
  };
}
```
```

  public shared(msg) func update_profile(bio: Text, displayName: Text): async () { 
    // Runtime validation check
    };
    
    // Implementation
  };
}
```

## Accessor Functions

Accessor functions extract specific fields from method arguments for validation. These are typically generated by the local codegen tool from your Candid interface:

```bash
# Generate accessor functions and types from your canister (from repo root)
npx ts-node tools/codegen/src/cli.ts path/to/your/canister.did --output generated-types.mo
```

**Generated accessor functions:**
```motoko
## ErasedValidator Pattern

The library solves the type erasure challenge using a **function generator** approach:

### Key Concepts

1. **Registration Time**: Full type information available
   ```motoko
   inspector.createMethodGuardInfo<M>(
     methodName: Text,
     isQuery: Bool, 
     rules: [ValidationRule<T,M>],
     msgAccessor: (T) -> M
   ) : MethodGuardInfo<T>
   ```
    Accessor functions extract specific fields from method arguments for validation. These are typically **generated by the local codegen tool** from your Candid interface:
2. **Type Erasure**: Validation logic "baked" into type-erased functions
   ```motoko
   public type ErasedValidator<T> = (InspectArgs<T>) -> Result<(), Text>
    # Generate accessor functions and types from your canister (from repo root)
    npx ts-node tools/codegen/src/cli.ts path/to/your/canister.did --output generated-types.mo

3. **Execution Time**: Simple function calls regardless of method-specific types
    #### DFX usage (manual)
    There are no prebuild hooks for Motoko canisters. Keep scripts in `package.json` and invoke codegen before builds:
    ```json
    // package.json
    {
      "scripts": {
        "codegen": "cd tools/codegen && npx ts-node src/cli.ts discover ../../ --generate",
        "build": "npm run codegen && dfx build"
      }
    }
    ```
All validation rules now follow the pattern `ValidationRule<T,M>` where:
- `T`: Message variant type (e.g., `MessageAccessor`)  
    **CI/CD Integration**
    Run codegen explicitly before builds:
    ```yaml
    - name: Generate helpers
      run: npm run codegen
    - name: Build canisters
      run: dfx build
    ```
### Text Size Validation
    npx ts-node tools/codegen/src/cli.ts discover ./my-project --suggest
// Validate bio field (first parameter) max 5KB
    3. **Auto-Discovery**: Use `npx ts-node tools/codegen/src/cli.ts discover . --suggest` to analyze
  func(args: (Text, Text)): Text { args.0 }, // accessor for bio receives M type
    # No install-hooks for Motoko canisters; use manual codegen before build
  ?5000                                      // max 5KB
        "codegen": "cd tools/codegen && npx ts-node src/cli.ts discover ../../ --generate"

// Validate displayName field (second parameter) 1-100 chars  
InspectMo.textSize<MessageAccessor, (Text, Text)>(
  func(args: (Text, Text)): Text { args.1 }, // accessor for displayName receives M type
  ?1,                                         // min 1 char
  ?100                                       // max 100 chars
)
```

### Blob Size Validation
```motoko
// Validate file upload max 2MB
InspectMo.blobSize<MessageAccessor, Blob>(
  func(blob: Blob): Blob { blob },    // accessor for single blob parameter receives M type
  ?100,                               // min 100 bytes
  ?2_000_000                         // max 2MB
)
```

### Permission-Based Rules
```motoko
// Require authenticated caller (non-anonymous)
InspectMo.requireAuth<MessageAccessor, (Text, Text)>()

// Require specific permission
InspectMo.requirePermission<MessageAccessor, (Text, Text)>("write")

// Require specific role  
InspectMo.requireRole<MessageAccessor, (Text, Text)>("admin")
```

### Access Control Rules
```motoko
// Block all ingress calls (allow only canister-to-canister)
InspectMo.blockIngress<MessageAccessor, (Text, Text)>()

// Block all calls (maintenance mode)
InspectMo.blockAll<MessageAccessor, (Text, Text)>()

// Allow only specific principals
InspectMo.allowedCallers<MessageAccessor, (Text, Text)>(
  Map.fromArray([
    (Principal.fromText("allowed-user"), ()),
    (Principal.fromText("another-user"), ())
  ], Principal.compare)
)
```

## Guard Validation

### Custom Business Logic
```motoko
InspectMo.customCheck<MessageAccessor, (Text, Text)>(
  func(args: InspectMo.CustomCheckArgs<MessageAccessor>): InspectMo.GuardResult { 
    // Access MessageAccessor variant and perform business logic
    switch (args.args) {
      case (#update_profile(bio, displayName)) {
        if (Text.size(bio) > 0 and Text.size(displayName) > 0) { #ok }
        else { #err("Bio and display name are required") }
      };
    }
  }
)
```

### Dynamic Authorization
```motoko
InspectMo.dynamicAuth<MessageAccessor, (Text, Text)>(
  func(args: InspectMo.DynamicAuthArgs<MessageAccessor>): InspectMo.GuardResult { 
    // Access auth provider and check permissions based on MessageAccessor
    switch (args.args) {
      case (#update_profile(bio, displayName)) {
        // Check if caller owns this profile
        if (args.caller == Principal.fromText("expected-owner")) { #ok }
        else { #err("You can only update your own profile") }
      };
      case (_) #err("Invalid message variant");
    }
  }
)
```

## Complete Examples

### File Upload Canister
```motoko
import InspectMo "mo:inspect-mo";



actor FileUploader {

  type InspectMessage = {
    #upload_metadata : Text -> ();
    #upload_file : (Blob, Text) -> FileId;
  };

  private let inspector = InspectMo.init<InspectMessage({
    allowAnonymous = ?false;
    updateDefaults = ?{
      maxArgSize = ?1_000_000; // 1MB default
    };
  });

  // Small metadata uploads
  inspector.inspect(inspector.createMethodGuardInfo<Text>(
    "upload_metadata",
    false,
    [
      InspectMo.textSize<MessageAccessor, Text>(func(text: Text): Text { text }, max = ?5_000),
      InspectMo.requireAuth()
    ],
    func(msg: MessageAccessor): Text {
      switch (msg) {
        case (#upload_metadata(metadata)) metadata;
        case (_) ""; // default fallback
      }
    }
  ));
  public func upload_metadata(metadata: Text): async () {
    // Implementation
  };

  // Large file uploads with comprehensive validation
  inspector.inspect(inspector.createMethodGuardInfo<(Blob, Text)>(
    "upload_file",
    false,
    [
      InspectMo.blobSize<MessageAccessor, (Blob, Text)>(func(args: (Blob, Text)): Blob { args.0 }, min = ?1, max = ?1_000_000),
      InspectMo.textSize<MessageAccessor, (Blob, Text)>(func(args: (Blob, Text)): Text { args.1 }, min = ?1, max = ?50),
      InspectMo.requireRole("uploader")
    ],
    func(msg: MessageAccessor): (Blob, Text) {
      switch (msg) {
        case (#upload_file(fileData, fileType)) (fileData, fileType);
        case (_) (Text.encodeUtf8(""), ""); // default fallback
      }
    }
  ));
  inspector.guard(inspector.createMethodGuardInfo<(Blob, Text)>(
    "upload_file",
    false,
    [
      InspectMo.customCheck<MessageAccessor, (Blob, Text)>(func(args: InspectMo.CustomCheckArgs<MessageAccessor>): InspectMo.GuardResult { 
        switch (args.msg) {
          case (#upload_file(fileData, fileType)) {
            if (isValidFileType(fileType)) { #ok }
            else { #err("Invalid file type: " # fileType) }
          };
          case (_) { #err("Invalid method") };
        }
      })
    ],
    func(msg: MessageAccessor): (Blob, Text) {
      switch (msg) {
        case (#upload_file(fileData, fileType)) (fileData, fileType);
        case (_) (Text.encodeUtf8(""), ""); // default fallback
      }
    }
  ));
  public func upload_file(fileData: Blob, fileType: Text): async FileId {
    let guardArgs: InspectMo.InspectArgs<MessageAccessor> = {
      methodName = "upload_file";
      caller = msg.caller;
      arg = to_candid(fileData, fileType);
      msg = #upload_file(fileData, fileType);
      isQuery = false;
      isInspect = false;
      cycles = ?msg.cycles;
      deadline = null;
    };
    switch (inspector.guardCheck(guardArgs)) {
      case (#ok) { /* continue */ };
      case (#err(msg)) { throw Error.reject(msg) };
    };
    // Implementation
  };

  system func inspect({
    caller : Principal;
    arg : Blob;
    msg : InspectMessage
  }) : Bool {
    let (methodName, isQuery) = switch (msg) {
      case (#upload_metadata _) { ("upload_metadata", false) };
      case (#upload_file _) { ("upload_file", false) };
    };
    
    let inspectArgs : InspectMo.InspectArgs = {
      caller = caller;
      arg = arg;
      methodName = methodName;
      isQuery = isQuery;
      isIngress = Principal.isAnonymous(caller);
      msg = msg;
      argTypes = [];
    };
    
    inspector.inspectCheck(inspectArgs)
  };
}
```

### DeFi Canister with Role-Based Access

**‚ö†Ô∏è EXAMPLE ONLY: The RBAC integration shown is for demonstration purposes and is not production-ready.**

```motoko
import InspectMo "mo:inspect-mo";
import Permissions "mo:rbac";

actor DeFiCanister {
  private var permissions = Permissions.init();
  
  type InspectMessage = {
    #get_balance: () -> Nat;
    #transfer: () -> (Principal, Nat);
    #admin_set_fee :  Nat -> ();
  }
  
  // NOTE: This is an example integration pattern only
  private let inspector = InspectMo.init<InspectMessage>({
    allowAnonymous = ?false;
    authProvider = ?permissions;
    
    queryDefaults = ?{
      allowAnonymous = ?true;
      maxArgSize = ?1_000;
    };
    updateDefaults = ?{
      allowAnonymous = ?false;
      maxArgSize = ?10_000;
    };
  });

  // Public queries ....but only inspects for converted to update calls
  inspector.inspect(inspector, "get_balance", []);
  public query func get_balance(account: Principal): async Nat {
    // Implementation
  };

  // User operations
  inspector.inspect(inspector.createMethodGuardInfo<(Principal, Nat)>(
    "transfer",
    false,
    [
      InspectMo.requirePermission("transfer"),
      InspectMo.natValue<MessageAccessor, (Principal, Nat)>(func(args: (Principal, Nat)): Nat { args.1 }, max = ?1_000_000)
    ],
    func(msg: MessageAccessor): (Principal, Nat) {
      switch (msg) {
        case (#transfer(to, amount)) (to, amount);
        case (_) (Principal.fromText("2vxsx-fae"), 0); // default fallback
      }
    }
  ));
  inspector.guard([
    InspectMo.dynamicAuth<(Principal, Nat)>(func(args: DynamicAuthArgs<(Principal, Nat)>): GuardResult { 
      let (to, amount) = args.args;
      if (hasTransferPermission(args.caller, to, amount)) { #ok }
      else { #err("Transfer not authorized") }
    })
  ]);
  public func transfer(to: Principal, amount: Nat): async Result<(), Text> {
    switch (inspector.guardCheck("transfer", msg.caller)) {
      case (#ok) { /* continue */ };
      case (#err(msg)) { throw Error.reject(msg) };
    };
    // Implementation
  };

  // Admin operations
  inspector.inspect(inspector.createMethodGuardInfo<Nat>(
    "admin_set_fee",
    false,
    [
      InspectMo.requireRole("admin"),
      InspectMo.natValue<MessageAccessor, Nat>(func(amount: Nat): Nat { amount }, max = ?10_000)
    ],
    func(msg: MessageAccessor): Nat {
      switch (msg) {
        case (#admin_set_fee(amount)) amount;
        case (_) 0; // default fallback
      }
    }
  ));
  //must still do guard because updates via Other canisters don't go through inspect
  inspector.guard(inspector.createMethodGuardInfo<Nat>(
    "admin_set_fee",
    false,
    [
      InspectMo.requireRole("admin"),
      InspectMo.natValue<MessageAccessor, Nat>(func(amount: Nat): Nat { amount }, max = ?10_000)
    ],
    func(msg: MessageAccessor): Nat {
      switch (msg) {
        case (#admin_set_fee(amount)) amount;
        case (_) 0; // default fallback
      }
    }
  ));
  public func admin_set_fee(newFee: Nat): async () {
    //must still do guard because updates via Other canisters don't go through inspect
      case (#err(msg)) { throw Error.reject(msg) };
    };
  system func inspect({
    caller : Principal;
  }) : Bool {
    let (methodName, isQuery) = switch (msg) {
    };
    
    let inspectArgs : InspectMo.InspectArgs = {
      caller = caller;
      arg = arg;
      methodName = methodName;
      isQuery = isQuery;
      isIngress = Principal.isAnonymous(caller);
      msg = msg;
      argTypes = [];
    };
    
    inspector.inspectCheck(inspectArgs)
  };
}
```

## Configuration Options

### Inspector Initialization
```motoko
// Configuration type
private let config: InspectMo.InitArgs = {
  allowAnonymous: ?Bool;         // Global default for anonymous access
  defaultMaxArgSize: ?Nat;       // Global default argument size limit
  authProvider: ?AuthProvider;   // Permission system integration
  rateLimit: ?RateLimitConfig;   // Global rate limiting
  
  queryDefaults: ?{              // Defaults for query methods
    allowAnonymous: ?Bool;
    maxArgSize: ?Nat;
    rateLimit: ?RateLimitConfig;
  };
  updateDefaults: ?{             // Defaults for update methods
    allowAnonymous: ?Bool;
    maxArgSize: ?Nat;
    rateLimit: ?RateLimitConfig;
  };
  
  developmentMode: Bool;         // Enable relaxed rules for testing
  auditLog: Bool;               // Enable audit logging
};

// Initialize with Class Plus integration
private let inspectMo = InspectMo.InspectMo(
  null, // migration state
  Principal.fromActor(MyCanister), // self principal
  Principal.fromActor(MyCanister), // canister principal
  ?config,
  null, // environment
  func(state) {} // state update callback
);

// Create typed inspector
private let inspector = inspectMo.createInspector<MessageAccessor>();
```

### Rate Limiting Configuration
```motoko
let rateLimitConfig: InspectMo.RateLimitConfig = {
  maxPerMinute: ?Nat;
  maxPerHour: ?Nat;
  maxPerDay: ?Nat;
  maxPerHour: ?Nat;
  maxPerDay: ?Nat;
  exemptRoles: ?[Text];
})
```

## Error Handling

### GuardResult Type
```motoko
public type GuardResult = {
  #ok;
  #err: Text;
};
```

### Runtime Validation
```motoko
public func my_method(arg: T): async () {
  let guardArgs: InspectMo.InspectArgs<MessageAccessor> = {
    methodName = "my_method";
    caller = msg.caller;
    arg = to_candid(arg);
    msg = #my_method(arg);
    isQuery = false;
    isInspect = false;
    cycles = ?msg.cycles;
    deadline = null;
  };
  switch (inspector.guardCheck(guardArgs)) {
    case (#ok) { /* continue with implementation */ };
    case (#err(message)) { 
      // Log error, perform cleanup, etc.
      throw Error.reject(message) 
    };
  };
  
  // Method implementation
};
```

## Best Practices

### 1. Layered Security
- Use **inspect** for validation in system inspect_message (size limits, basic auth)
- Use **guard** for complex business logic and dynamic state checks

### 2. Performance Optimization
- Keep accessor functions simple and fast
- Use inspect validation to reject obviously invalid requests early
- Cache permission checks when possible

### 3. Error Messages
- Provide clear, actionable error messages in guard functions
- Avoid exposing sensitive system information in error messages

### 4. Testing
- Test both inspect and guard validation paths
- Test with various argument sizes and types
- Test permission edge cases and role changes

## Migration Guide

### From Manual inspect_message
```motoko
// Old approach
system func inspect({ caller; arg; msg }) : Bool {
  switch (msg) {
    case (#upload(data)) {
      data.size() <= 1_000_000 and not Principal.isAnonymous(caller)
    };
    case (_) { true };
  }
};

// New approach with Inspect-Mo
inspector.inspect(inspector.createMethodGuardInfo<Blob>(
  "upload",
  false,
  [
    InspectMo.blobSize<MessageAccessor, Blob>(func(blob: Blob): Blob { blob }, max = ?1_000_000),
    InspectMo.requireAuth()
  ],
  func(msg: MessageAccessor): Blob {
    switch (msg) {
      case (#upload(data)) data;
      case (_) Text.encodeUtf8(""); // default fallback
    }
  }
));
```

This provides better type safety, composability, and maintainability while achieving the same security goals.

## Code Generation Tool

The Inspect-Mo project includes a TypeScript-based code generation tool that automates the creation of simple, type-safe validation boilerplate from Candid (.did) interface files.

### Installation & Setup

```bash
# Install dependencies (run from project root)
cd tools/codegen
npm install
npm run build
```

### Auto-Discovery

The tool features intelligent auto-discovery that prioritizes the canonical `src/declarations` directory created by `dfx generate`:

```bash
# Discover .did files and analyze project structure
cd tools/codegen
npx ts-node src/cli.ts discover ../../ --suggest

# Example output:
# üìÅ Found src/declarations - using as primary source for .did files
# üìä Project Analysis:
#    ‚Ä¢ 3 .did file(s) found
#    ‚Ä¢ 12 InspectMo usage(s) detected
```

**Auto-Discovery Logic:**
1. **Primary Source**: If `src/declarations/` exists (from `dfx generate`), prioritize these canonical interface files
2. **Fallback Sources**: Otherwise search project-wide with intelligent filtering
3. **Smart Filtering**: Automatically excludes build artifacts:
   - ‚ùå `.dfx/local/lsp/` (temporary LSP files)
   - ‚ùå `constructor.did` files (usually not needed)
   - ‚ùå `.mops/`, `.vessel/`, `node_modules/` (package managers)
   - ‚úÖ `src/declarations/*/service.did` (main interfaces)
   - ‚úÖ `did/` folder (explicit project interfaces)

### Basic Usage

```bash
# Generate from a single .did file
cd tools/codegen
npx ts-node src/cli.ts generate ../../src/declarations/test_canister/test_canister.did -o ../../src/generated/test_canister-inspect.mo

# Auto-discover and generate from project
npx ts-node src/cli.ts discover ../../ --generate

# Analyze existing InspectMo usage
npx ts-node src/cli.ts discover ../../ --suggest
```

### Generated Code Structure

The tool generates simple, practical Motoko modules with Args union types and accessor functions:

```motoko
/// Auto-generated InspectMo integration module
import InspectMo "mo:inspect-mo/lib";
import Types "./test_canister-inspect_types";


  /// Args union type for ErasedValidator pattern
  public type Args = {
    #get_info: ();
    #send_message: Text;
  };

  /// Simple accessor functions
  public func getSendMessageMessage(args: Args): Text {
    switch (args) {
      case (#send_message(value)) value;
      case (_) "";
    };
  };

  public func getGuardedMethodData(args: Args): Text {
    switch (args) {
      case (#guarded_method(value)) value;
      case (_) "";
    };
  };
}
```

### Build System Integration
```json
// package.json
{
  "scripts": {
    "codegen": "cd tools/codegen && npx ts-node src/cli.ts discover ../../ --generate",
    "build": "npm run codegen && dfx build",
    "test": "npm run codegen && mops test"
  }
}
```

#### Mops Integration (‚ùå Not Supported)
```bash
# mops.toml does not support prebuild hooks - manual workflow required
npm run codegen  # Run before mops test
mops test
```

**Limitation**: mops.toml configuration format does not support build hooks or prebuild scripts according to the [official mops documentation](https://docs.mops.one/).

### Advanced Features

#### Complex Type Handling
The tool uses a delegated field extraction pattern to handle complex and recursive types:

```motoko
// Instead of automatic parsing (error-prone):
// ‚ùå getField(complexRecord, "deeply.nested.field")

// Uses user-controlled extraction (type-safe):
// ‚úÖ func(args: MyArgs): Text { args.user.profile.displayName }
```

#### Project Analysis
```bash
# Comprehensive project analysis
npx ts-node tools/codegen/src/cli.ts discover ./my-project --suggest

# Output includes:
# - .did file discovery with filtering
# - Existing InspectMo usage detection  
# - Build system integration suggestions
# - Missing validation opportunities
```

#### Development Workflow

1. **Design Phase**: Create your canister interface (.did files)
2. **Generate Phase**: Run `dfx generate` to create `src/declarations/`
3. **Auto-Discovery**: Use `npx ts-node tools/codegen/src/cli.ts discover . --suggest` to analyze
4. **Code Generation**: Generate validation boilerplate with delegated accessors
5. **Customization**: Implement user-controlled field extraction functions

#### Build System Integration

The code generation tool integrates with your build system to automate InspectMo code generation:

**DFX Integration (‚úÖ Fully Supported)**
```bash
# Install build hooks
// No install-hooks for Motoko canisters; use manual codegen before builds
```

Recommended: run code generation manually before builds:
```json
{
  "scripts": {
  "codegen": "cd tools/codegen && npx ts-node src/cli.ts discover ../../ --generate"
  },
  "canisters": {
    "main": {
  # npm run codegen
    }
  }
}
```

**Mops Integration (‚ùå Not Supported)**
- mops.toml does not support build hooks or prebuild scripts
- Manual workflow required: run `npm run codegen` before `mops test`
- See [mops documentation](https://docs.mops.one/) for confirmed limitations

**CI/CD Integration**
With DFX integration, no extra CI steps needed:
```yaml
# GitHub Actions - run codegen manually before build
- name: Build canisters
  run: dfx build  # Automatically runs npm run codegen
```
6. **Integration**: Add to build system for automatic regeneration

### CLI Reference

```bash
# Discovery commands (run from tools/codegen directory)
npx ts-node src/cli.ts discover <path>           # Analyze project structure
npx ts-node src/cli.ts discover <path> --suggest # Show integration suggestions  
npx ts-node src/cli.ts discover <path> --generate # Auto-generate

# Generation commands
npx ts-node src/cli.ts generate <did-file> -o <output>    # Single file generation

# Build integration commands
# No DFX prebuild hooks for Motoko canisters; use manual codegen commands
npx ts-node src/cli.ts status <path>            # Check integration status

# Options
--output, -o <path>     # Output file or directory
--suggest              # Show build integration suggestions
--generate             # Generate code during discovery
```

The code generation tool significantly reduces the boilerplate needed to set up InspectMo validation while maintaining type safety and providing simple, practical validation code that matches your actual Candid interfaces.
